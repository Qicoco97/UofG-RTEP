{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Video-based Baby Monitor Overview The baby monitor is a contactless, video-based baby monitor. This is a C++ implementation of the MIT Video Magnification algorithm that is tuned to run on a Raspberry Pi 3 Model B and easily extensible. You can setup your own baby monitor that raises an alarm if your infant stops moving. However, the monitor will not work as expected if the system is not calibrated properly. If the system is not calibrated well or the environment in the video is not conducive to video magnification, you may not be able to use it. Getting Started The baby monitor is made up of two parts: the baby monitoring software and some simple hardware. Find out all you need to know about how to use and recreate your own monitor in the sections below. Software To install the prerequisites, build the software, or learn more about the software architecture, see the Software Setup Guide . Hardware To learn more about the hardware materials we used, and how we build our setup, check out the Hardware Setup Guide . Video Walkthroughs TODO","title":"Home"},{"location":"#video-based-baby-monitor-overview","text":"The baby monitor is a contactless, video-based baby monitor. This is a C++ implementation of the MIT Video Magnification algorithm that is tuned to run on a Raspberry Pi 3 Model B and easily extensible. You can setup your own baby monitor that raises an alarm if your infant stops moving. However, the monitor will not work as expected if the system is not calibrated properly. If the system is not calibrated well or the environment in the video is not conducive to video magnification, you may not be able to use it.","title":"Video-based Baby Monitor Overview"},{"location":"#getting-started","text":"The baby monitor is made up of two parts: the baby monitoring software and some simple hardware. Find out all you need to know about how to use and recreate your own monitor in the sections below.","title":"Getting Started"},{"location":"#software","text":"To install the prerequisites, build the software, or learn more about the software architecture, see the Software Setup Guide .","title":"Software"},{"location":"#hardware","text":"To learn more about the hardware materials we used, and how we build our setup, check out the Hardware Setup Guide .","title":"Hardware"},{"location":"#video-walkthroughs","text":"TODO","title":"Video Walkthroughs"},{"location":"setup/config/","text":"Configuration Configuration of baby monitor uses a file which is usually located in /etc/babymonitor/config.ini . The format is that of INI files: each line is a configuration value, and directives are grouped in section introduced by square brackets. Comments are delimited with ; to the end of the line. Input/Output The [io] section of the file configures the input to baby monitor. You should not need to modify this section, as it is already calibrated to work on the Raspberry Pi. The input directive specifies that the magnifier should look for a video file instead of real-time camera input, while camera directive chooses the camera device to use (eg. camera = 0 means to use /dev/video0 as input). File input exists as a demo or debugging feature only. If you change the input, you must also specify the fps parameters to match the input. For file input, there is only one fps setting, because frames are never dropped, while for camera input, to reduce latency you must specify the frame per second at full frame size and at cropped frame size (roughly 3x the full frame size fps). The latter values depend on the speed of the CPU on which baby monitor run. Note that when using an input file that is less than 15 fps, crop_fps should be set to the input file's fps value in order to ensure the bandpass frequencies are calculated correctly. time_to_alarm determines the number of system-time seconds to wait after baby monitor stops seeing motion before playing an alarm sound through the audio port. Cropping The [cropping] section controls the adaptive motion-based cropping, which focuses the magnification process on a smaller Region of Interest (ROI) where the most motion is occurring, reducing the CPU load. The different parameters affect the latency of detection, as they control the number of \"slow\" frames (fully uncropped). Optimal values for the parameters depend on the target CPU. If you're running on a different device than the Pi, and it's sufficiently powerful, you can also disable cropping altogether. The default configuration will update the crop approximately every minute. Motion & Magnification The [motion] and [magnification] sections control the motion detection and video magnification algorithm respectively. These parameters depend on the setting in which the baby monitor is deployed, such as lighting condition and contrast on the baby. In general, you should not need to change the magnification setting, as it is tuned to detect normal breathing rates. Calibration may be needed for erode_dim and dilate_dim , which are used to determine where to crop the video, as well as diff_threshold and pixel_threshold which determine the thresholds used judge the magnitude of change in pixels and the number of pixels of motion are needed before being classified as motion rather than noise. Specifically, diff_threshold specifies the amount of change a grayscale pixel (value between 0 and 255) will need to change before being marked as changed. For example, if diff_threshold is 30, the difference between a pixels has to be equal to or more than 30 to be marked changed. The higher this threshold, the more the pixels needs to be different to be marked. pixel_threshold defines a hard cut of in the number of pixels that need to be marked as changed before outputting motion values. This effectively sets the cutoff for noise when determining whether or not an infant is breathing. For example, if pixel_threshold is set to 100, the algorithm must see more than 100 pixels of change before registering any motion as seen. It will report no motion if that threshold is not crossed. erode_dim specifies the dimension of the kernel to use in an OpenCV erode operation . This is used to minimize the changed pixels. That is, pixels that are isolated will be removed, but when large groups of pixels are changed, they will remain. dilate_dim is the opposite, it takes a pixels and expands it. These two parameters are used when detecting the region of the frame that the infant is located in. First, the pixel differences are calculated, then, a small erosion is applied to eliminate noise and a large dilation is applied to broadly mark the areas of motion. low-cuttoff and high-cutoff define the range of the bandpass filter used during magnification. Specifically, video magnification will try to magnify motion that occurs within this frequency range, and ignore motion outside this range. We've tuned this to be able to capture breathing rats in general, but you may need to tweak this during calibration. See the section on calibration for more information. Debugging features The show_diff flag in [motion] will show a window where the areas where motion is detected in the frame are highlighted in white. The show_magnification flag in [magnification] controls a window that shows the output of just video magnification (which should look like the camera feed, in black and white, with enlarged motion). You can use these two flags to show the result of your changes to the motion and magnification parameters. Finally, the print_times in the [debug] section controls printing of frame times in the standard output, which you can use to calibrate the FPS and latency settings when running on a device different than the Raspberry Pi. These features must be left to off when baby monitor is started through systemd (automatically on boot or with systemctl start ). They are only useful if you run baby monitor manually. Calibrating the Motion & Magnification algorithm Calibration of the algorithm is an iterative effort, with no right or wrong answer. We encourage you to experiment with various values, combining them with the debugging features, to find the combination of parameters most suitable to your environment. As a guideline, increasing the amplification and the phase_threshold values increases the amount of magnification applied to the input video. You should change these values until you clearly see the movement from your baby breathing, and no significant artifact in other areas of the video. If you experience artifacts, reducing the phase_threshold while keeping the same amplification might help. You can view the effects of these parameters by setting show_magnification to true . As for the motion detection parameters, the main driver is the amount of noise. When detecting regions of motion to crop to, erode_dim and dilate_dim are used to size the dimensions of the OpenCV kernels used to erode and dilate motion so that noise is first eroded away, then the remaining motion signal is significantly dilated to make the regions of motion obvious. These parameters may also need to be tuned if your crib is in a very high-contrast setting. In general, you will need a higher erode_dim for high contrast settings, and a lower erode_dim for low contrast. If you run with show_diff = true and you notice that too much of the input video is white, or some completely unrelated part of the video is detected as motion (e.g. a flickering lamp), you'll want to increase the erode_dim until only the part of the video corresponding to your breathing baby is the largest section of white. The top figure shows an example where the erode dimension is too low for the amount of motion in the frame, while the bottom one shows a correctly calibrated frame. Once this has been calibrated, you'll want to make sure that the pixel_threshold is set so that motion is only reported when you expect, and not constantly (which means you need to cut out the noise). Ideally, you'll see output like this in your terminal: [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 44 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 161 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 121 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 86 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 97 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 74 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 60 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 48 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 38 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 29 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 28 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 22 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz Where there is a clear periodic pattern corresponding to the motion. If your output looks more like this: [info] Pixel Movement: 921 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 736 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 666 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 663 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 1196 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 1235 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 1187 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 1115 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 959 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 744 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 611 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 468 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 371 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 307 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 270 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 234 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 197 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 179 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 164 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 239 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 733 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 686 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 667 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 607 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 544 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 499 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 434 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 396 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 375 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 389 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 305 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 269 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 1382 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 1086 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 1049 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 811 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 601 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 456 [info] Motion Estimate: 1.312346 Hz Then you'll need to adjust pixel_threshold and diff_threshold until just peaks are seen, and pixel movement is 0 otherwise.","title":"Software Configuration Parameters"},{"location":"setup/config/#configuration","text":"Configuration of baby monitor uses a file which is usually located in /etc/babymonitor/config.ini . The format is that of INI files: each line is a configuration value, and directives are grouped in section introduced by square brackets. Comments are delimited with ; to the end of the line.","title":"Configuration"},{"location":"setup/config/#inputoutput","text":"The [io] section of the file configures the input to baby monitor. You should not need to modify this section, as it is already calibrated to work on the Raspberry Pi. The input directive specifies that the magnifier should look for a video file instead of real-time camera input, while camera directive chooses the camera device to use (eg. camera = 0 means to use /dev/video0 as input). File input exists as a demo or debugging feature only. If you change the input, you must also specify the fps parameters to match the input. For file input, there is only one fps setting, because frames are never dropped, while for camera input, to reduce latency you must specify the frame per second at full frame size and at cropped frame size (roughly 3x the full frame size fps). The latter values depend on the speed of the CPU on which baby monitor run. Note that when using an input file that is less than 15 fps, crop_fps should be set to the input file's fps value in order to ensure the bandpass frequencies are calculated correctly. time_to_alarm determines the number of system-time seconds to wait after baby monitor stops seeing motion before playing an alarm sound through the audio port.","title":"Input/Output"},{"location":"setup/config/#cropping","text":"The [cropping] section controls the adaptive motion-based cropping, which focuses the magnification process on a smaller Region of Interest (ROI) where the most motion is occurring, reducing the CPU load. The different parameters affect the latency of detection, as they control the number of \"slow\" frames (fully uncropped). Optimal values for the parameters depend on the target CPU. If you're running on a different device than the Pi, and it's sufficiently powerful, you can also disable cropping altogether. The default configuration will update the crop approximately every minute.","title":"Cropping"},{"location":"setup/config/#motion-magnification","text":"The [motion] and [magnification] sections control the motion detection and video magnification algorithm respectively. These parameters depend on the setting in which the baby monitor is deployed, such as lighting condition and contrast on the baby. In general, you should not need to change the magnification setting, as it is tuned to detect normal breathing rates. Calibration may be needed for erode_dim and dilate_dim , which are used to determine where to crop the video, as well as diff_threshold and pixel_threshold which determine the thresholds used judge the magnitude of change in pixels and the number of pixels of motion are needed before being classified as motion rather than noise. Specifically, diff_threshold specifies the amount of change a grayscale pixel (value between 0 and 255) will need to change before being marked as changed. For example, if diff_threshold is 30, the difference between a pixels has to be equal to or more than 30 to be marked changed. The higher this threshold, the more the pixels needs to be different to be marked. pixel_threshold defines a hard cut of in the number of pixels that need to be marked as changed before outputting motion values. This effectively sets the cutoff for noise when determining whether or not an infant is breathing. For example, if pixel_threshold is set to 100, the algorithm must see more than 100 pixels of change before registering any motion as seen. It will report no motion if that threshold is not crossed. erode_dim specifies the dimension of the kernel to use in an OpenCV erode operation . This is used to minimize the changed pixels. That is, pixels that are isolated will be removed, but when large groups of pixels are changed, they will remain. dilate_dim is the opposite, it takes a pixels and expands it. These two parameters are used when detecting the region of the frame that the infant is located in. First, the pixel differences are calculated, then, a small erosion is applied to eliminate noise and a large dilation is applied to broadly mark the areas of motion. low-cuttoff and high-cutoff define the range of the bandpass filter used during magnification. Specifically, video magnification will try to magnify motion that occurs within this frequency range, and ignore motion outside this range. We've tuned this to be able to capture breathing rats in general, but you may need to tweak this during calibration. See the section on calibration for more information.","title":"Motion &amp; Magnification"},{"location":"setup/config/#debugging-features","text":"The show_diff flag in [motion] will show a window where the areas where motion is detected in the frame are highlighted in white. The show_magnification flag in [magnification] controls a window that shows the output of just video magnification (which should look like the camera feed, in black and white, with enlarged motion). You can use these two flags to show the result of your changes to the motion and magnification parameters. Finally, the print_times in the [debug] section controls printing of frame times in the standard output, which you can use to calibrate the FPS and latency settings when running on a device different than the Raspberry Pi. These features must be left to off when baby monitor is started through systemd (automatically on boot or with systemctl start ). They are only useful if you run baby monitor manually.","title":"Debugging features"},{"location":"setup/config/#calibrating-the-motion-magnification-algorithm","text":"Calibration of the algorithm is an iterative effort, with no right or wrong answer. We encourage you to experiment with various values, combining them with the debugging features, to find the combination of parameters most suitable to your environment. As a guideline, increasing the amplification and the phase_threshold values increases the amount of magnification applied to the input video. You should change these values until you clearly see the movement from your baby breathing, and no significant artifact in other areas of the video. If you experience artifacts, reducing the phase_threshold while keeping the same amplification might help. You can view the effects of these parameters by setting show_magnification to true . As for the motion detection parameters, the main driver is the amount of noise. When detecting regions of motion to crop to, erode_dim and dilate_dim are used to size the dimensions of the OpenCV kernels used to erode and dilate motion so that noise is first eroded away, then the remaining motion signal is significantly dilated to make the regions of motion obvious. These parameters may also need to be tuned if your crib is in a very high-contrast setting. In general, you will need a higher erode_dim for high contrast settings, and a lower erode_dim for low contrast. If you run with show_diff = true and you notice that too much of the input video is white, or some completely unrelated part of the video is detected as motion (e.g. a flickering lamp), you'll want to increase the erode_dim until only the part of the video corresponding to your breathing baby is the largest section of white. The top figure shows an example where the erode dimension is too low for the amount of motion in the frame, while the bottom one shows a correctly calibrated frame. Once this has been calibrated, you'll want to make sure that the pixel_threshold is set so that motion is only reported when you expect, and not constantly (which means you need to cut out the noise). Ideally, you'll see output like this in your terminal: [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 44 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 161 [info] Motion Estimate: 1.219812 Hz [info] Pixel Movement: 121 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 86 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 97 [info] Motion Estimate: 0.841416 Hz [info] Pixel Movement: 74 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 60 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 48 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 38 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 29 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 28 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 22 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz [info] Pixel Movement: 0 [info] Motion Estimate: 0.839298 Hz Where there is a clear periodic pattern corresponding to the motion. If your output looks more like this: [info] Pixel Movement: 921 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 736 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 666 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 663 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 1196 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 1235 [info] Motion Estimate: 1.352046 Hz [info] Pixel Movement: 1187 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 1115 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 959 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 744 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 611 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 468 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 371 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 307 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 270 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 234 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 197 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 179 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 164 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 239 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 733 [info] Motion Estimate: 1.456389 Hz [info] Pixel Movement: 686 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 667 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 607 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 544 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 499 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 434 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 396 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 375 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 389 [info] Motion Estimate: 1.229389 Hz [info] Pixel Movement: 305 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 269 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 1382 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 1086 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 1049 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 811 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 601 [info] Motion Estimate: 1.312346 Hz [info] Pixel Movement: 456 [info] Motion Estimate: 1.312346 Hz Then you'll need to adjust pixel_threshold and diff_threshold until just peaks are seen, and pixel movement is 0 otherwise.","title":"Calibrating the Motion &amp; Magnification algorithm"},{"location":"setup/hw-setup/","text":"Hardare Setup Guide Figure: Hardware Block Diagram Baby monitor is relatively easy to construct, and is largely made up of commercially available parts. As seen in the figure above, there are 5 main hardware components, only 2 of which are custom made. This page contains the build instructions for baby monitor. What you'll need Raspberry Pi + Camera + configuration tools: Raspberry Pi 3 Model B 5V 2.5A Micro USB Power Supply Raspberry Pi NoIR Camera Module V2 1W IR LED MicroSD Card (we used a Class 10 16GB card, the faster the card the better) Flex Cable for Raspberry Pi Camera (12\") Speakers with 3.5mm input HDMI monitor USB Keyboard USB Mouse [optional] Raspberry Pi Heatsink (If you're worried about heat, you can stick these onto your Pi.) IR LED Circuit for low-light operation: [3x] 1N4001 diodes 1 ohm, 1W resistor [2x] 12\" Wires with pin headers Soldering iron Chassis: Access to a 3D printer (minimum build volume = 9.9\" L x 7.8\" W x 5.9\" H) to print the chassis Glue (any type of glue will will work, but hot glue is recommended for prototyping) Prerequisites Before you start our step-by-step guide, you should have already installed the latest version of Raspbian on your SD card and ensured that your Pi is functional and booting. You'll also need to enable the camera module before you'll be able to interface with the camera. Build Instructions Swap NoIR Camera Cable The 6\" cable that comes with the camera is too short. Swap the short one (6\") with the longer one (12\"). To do this, you can follow this guide from ModMyPi . To summarize, there is a push/pull tab on the back of the NoIR camera, just like the one found on the Pi itself: Simply pull the black plastic tab out, remove the short cable, replace it with the long cable (making sure that the blue plastic strip is facing up still as shown in the picture), and push the tab back in to secure it. 3D Printed Chassis Using our chassis is optional, though recommended to prevent young children from touching exposed electronic circuitry. Every crib is different, so our chassis does not include include a mounting bracket. Several mounting options could include: Cable Ties 3M Dual Lock Velcro Tape If you have access to a MakerBot Replicator (5th Generation), you can simply download the .makerbot files for the case and cover onto your MakerBot Replicator and print. It takes about 6 hours to print the case and 3 hours to print the cover. If you are using a different type of 3D printer, please keep reading. As mentioned above, a minimum build volume of 9.9\" (L) x 7.8\" (W) x 5.9\" (H) is required to print baby monitor. If you do not have access to a 3D printer with this build volume, you can use an online 3D printing service (such as Shapeways or Sculpteo ) to print baby monitor. The minimum print resolution is 0.015\". If you are using a fused filament fabrication type 3D printer, this means that your nozzle diameter needs to be 0.015\" or smaller. Printers with lower print resolutions (larger nozzle diameters) may work, but the Raspberry Pi might not fit into the chassis. We recommend PLA (polylactic acid) as the preferred printing material. Other plastics may work, but the Raspberry Pi may not fit in the case if the thermal expansion coefficient of the chosen plastic is larger than that of PLA. If your 3D printer has a heated build plate, turn off the heater before proceeding. Orienting the model on your printer's build plate is critical for a successful print. These models were carefully designed so they do not need to be printed with support material, thus saving plastic and improving print quality. Before proceeding, download the 3D files for the case and cover . When printing these models, the neck of baby monitor must lay flat on the build plate. This ensures that all overhang angles on the models do not exceed 45 degrees, thus eliminating the requirement for support material. For instructions on orientating 3D models in the build volume of your printer, please refer to the instruction manual that comes with your 3D printer. Examples for the build orientation of the case and cover are shown below. Case: Cover: In addition to putting the neck of baby monitor flat against the build plate, you may notice that the models are rotated around the vertical axis. This may be necessary to fit the model inside the build volume of your 3D printer. This rotation is optional if the length of your build volume is long enough to accommodate baby monitor. IR LED Circuit In order to provide adequate lighting at night, we use an IR LED, which is not visible to the human eye but visible to the NoIR camera. The IR LED does not consume a lot of power compared to the Raspberry Pi, so we leave the IR LED on for the sake of simplicity. To power the LED from the GPIO header pins on the Pi, we construct the circuit in the figure below. Figure: LED Schematic In earlier versions of the Pi, the maximum output current of these pins was 50mA . The Raspberry Pi B+ increased this to 500mA. However, for simplicity and backwards compatibility, we use the 5V power pins, which can supply up to 1.5A . The forward voltage of the IR LED is about 1.7~1.9V according to our measurements. Even though the IR LED has a maximum current of 500mA, we decided to reduce the current to around 200mA to reduce heat and overall power consumption. Experimental results also show that the IR LED is bright enough with 200 mA of input current. To bridge the gap between 5V and 1.9V, we decided to use three 1N4001 diodes and a 1 Ohm resistor in series with the IR LED. The voltage drop over the wire, diodes and resistor is about 0.2V, 0.9V (for each one) and 0.2V, respectively. Thus, the voltage over the IR LED is 5V - 0.2V - (3 * 0.9V) - 0.2V = 1.9V . The heat dissipation over each LED is 0.18W, and is 0.2W over the resistor, all well within the maximum ratings. The circuit should looking something like this: But, we're not done yet! In order to get a better fit in the 3D printed chassis, we want to have the IR LED lens protrude from our chassis and have the PCB board flush with the hole. The small photodiode in the bottom right will get in the way. To remedy this, we desolder it and flip it to the opposite side of the board like this: The photodiode is not needed since we want the LED to always be on. Simply switching it to the opposite side leaves the original LED circuit unchanged. Assembly: Bring it all together Once you have all the hardware ready, you can begin assembly. Any glue can be used in this process, but we recommend hot glue for two main reasons. Hot glue drys quickly, so you do not need to wait a long time for the glue to dry. In addition, hot glue is removable if you make a mistake. To remove dried hot glue, soak the hot glue in in rubbing (isopropyl) alcohol. We recommend 90% concentration or higher, but 70% concentration will still work. Soaking the dried hot glue in isopropyl alcohol will weaken the bond between the glue and underlying surface, allowing you to peel the glue off cleanly. When soaking the glue in isopropyl alcohol, the Raspberry Pi should be powered off and unplugged. Be sure to let everything dry before reapplying hot glue and booting the Raspberry Pi. The assembly instructions below assume that you are using hot glue. If you are using a different type of glue, the assembly instructions still apply, though the drying times may differ. Throughout this process, make sure that the glue is dry before moving on to the next step. Throughout the build, check to make sure that all the ports can still be accessed through the holes in the baby monitor chassis. Click any of the pictures below for higher resolution images. Insert the Raspberry Pi into the chassis. Once it is in place, be sure that all of the ports can still be accessed (e.g. you can plug in power power). Next, use hot glue to tack the Pi into place and attach the camera to the Pi. There are screw holes as well if you prefer to use those. Glue the LED and camera to the front cover. First, glue the NoIR camera to the camera hole. Be sure that the camera is snug and lined up with the chassis. Do not use too much glue; otherwise, you will not be able to fit the camera into the main case. Be sure to power on the Pi and take a look at the camera ( raspistill -v , for example) to make sure that it is angled well and has a good field of view. If it is not, remove the hot glue and reposition it. Next, glue the IR LED to the hole on the neck of the cover. It's at a 45 degree angle to side light the crib, which results in more shadows in low-light situations. This adds more contrast to the image, making it easier to detect motion. With both of them glued to the neck, it should look like this: Attach the IR LED wires to the Raspberry Pi's GPIO pins as shown in the LED Schematic figure. Pack the cables into the chassis in a way that does not crease or strain them. We ended up folding the cable accordion style because our camera flex cable was too long. With everything tucked in, hot glue around the edges where the two pieces meet, sealing them in place.","title":"Hardware Setup Instructions"},{"location":"setup/hw-setup/#hardare-setup-guide","text":"Figure: Hardware Block Diagram Baby monitor is relatively easy to construct, and is largely made up of commercially available parts. As seen in the figure above, there are 5 main hardware components, only 2 of which are custom made. This page contains the build instructions for baby monitor.","title":"Hardare Setup Guide"},{"location":"setup/hw-setup/#what-youll-need","text":"Raspberry Pi + Camera + configuration tools: Raspberry Pi 3 Model B 5V 2.5A Micro USB Power Supply Raspberry Pi NoIR Camera Module V2 1W IR LED MicroSD Card (we used a Class 10 16GB card, the faster the card the better) Flex Cable for Raspberry Pi Camera (12\") Speakers with 3.5mm input HDMI monitor USB Keyboard USB Mouse [optional] Raspberry Pi Heatsink (If you're worried about heat, you can stick these onto your Pi.) IR LED Circuit for low-light operation: [3x] 1N4001 diodes 1 ohm, 1W resistor [2x] 12\" Wires with pin headers Soldering iron Chassis: Access to a 3D printer (minimum build volume = 9.9\" L x 7.8\" W x 5.9\" H) to print the chassis Glue (any type of glue will will work, but hot glue is recommended for prototyping)","title":"What you'll need"},{"location":"setup/hw-setup/#prerequisites","text":"Before you start our step-by-step guide, you should have already installed the latest version of Raspbian on your SD card and ensured that your Pi is functional and booting. You'll also need to enable the camera module before you'll be able to interface with the camera.","title":"Prerequisites"},{"location":"setup/hw-setup/#build-instructions","text":"","title":"Build Instructions"},{"location":"setup/hw-setup/#swap-noir-camera-cable","text":"The 6\" cable that comes with the camera is too short. Swap the short one (6\") with the longer one (12\"). To do this, you can follow this guide from ModMyPi . To summarize, there is a push/pull tab on the back of the NoIR camera, just like the one found on the Pi itself: Simply pull the black plastic tab out, remove the short cable, replace it with the long cable (making sure that the blue plastic strip is facing up still as shown in the picture), and push the tab back in to secure it.","title":"Swap NoIR Camera Cable"},{"location":"setup/hw-setup/#3d-printed-chassis","text":"Using our chassis is optional, though recommended to prevent young children from touching exposed electronic circuitry. Every crib is different, so our chassis does not include include a mounting bracket. Several mounting options could include: Cable Ties 3M Dual Lock Velcro Tape If you have access to a MakerBot Replicator (5th Generation), you can simply download the .makerbot files for the case and cover onto your MakerBot Replicator and print. It takes about 6 hours to print the case and 3 hours to print the cover. If you are using a different type of 3D printer, please keep reading. As mentioned above, a minimum build volume of 9.9\" (L) x 7.8\" (W) x 5.9\" (H) is required to print baby monitor. If you do not have access to a 3D printer with this build volume, you can use an online 3D printing service (such as Shapeways or Sculpteo ) to print baby monitor. The minimum print resolution is 0.015\". If you are using a fused filament fabrication type 3D printer, this means that your nozzle diameter needs to be 0.015\" or smaller. Printers with lower print resolutions (larger nozzle diameters) may work, but the Raspberry Pi might not fit into the chassis. We recommend PLA (polylactic acid) as the preferred printing material. Other plastics may work, but the Raspberry Pi may not fit in the case if the thermal expansion coefficient of the chosen plastic is larger than that of PLA. If your 3D printer has a heated build plate, turn off the heater before proceeding. Orienting the model on your printer's build plate is critical for a successful print. These models were carefully designed so they do not need to be printed with support material, thus saving plastic and improving print quality. Before proceeding, download the 3D files for the case and cover . When printing these models, the neck of baby monitor must lay flat on the build plate. This ensures that all overhang angles on the models do not exceed 45 degrees, thus eliminating the requirement for support material. For instructions on orientating 3D models in the build volume of your printer, please refer to the instruction manual that comes with your 3D printer. Examples for the build orientation of the case and cover are shown below. Case: Cover: In addition to putting the neck of baby monitor flat against the build plate, you may notice that the models are rotated around the vertical axis. This may be necessary to fit the model inside the build volume of your 3D printer. This rotation is optional if the length of your build volume is long enough to accommodate baby monitor.","title":"3D Printed Chassis"},{"location":"setup/hw-setup/#ir-led-circuit","text":"In order to provide adequate lighting at night, we use an IR LED, which is not visible to the human eye but visible to the NoIR camera. The IR LED does not consume a lot of power compared to the Raspberry Pi, so we leave the IR LED on for the sake of simplicity. To power the LED from the GPIO header pins on the Pi, we construct the circuit in the figure below. Figure: LED Schematic In earlier versions of the Pi, the maximum output current of these pins was 50mA . The Raspberry Pi B+ increased this to 500mA. However, for simplicity and backwards compatibility, we use the 5V power pins, which can supply up to 1.5A . The forward voltage of the IR LED is about 1.7~1.9V according to our measurements. Even though the IR LED has a maximum current of 500mA, we decided to reduce the current to around 200mA to reduce heat and overall power consumption. Experimental results also show that the IR LED is bright enough with 200 mA of input current. To bridge the gap between 5V and 1.9V, we decided to use three 1N4001 diodes and a 1 Ohm resistor in series with the IR LED. The voltage drop over the wire, diodes and resistor is about 0.2V, 0.9V (for each one) and 0.2V, respectively. Thus, the voltage over the IR LED is 5V - 0.2V - (3 * 0.9V) - 0.2V = 1.9V . The heat dissipation over each LED is 0.18W, and is 0.2W over the resistor, all well within the maximum ratings. The circuit should looking something like this: But, we're not done yet! In order to get a better fit in the 3D printed chassis, we want to have the IR LED lens protrude from our chassis and have the PCB board flush with the hole. The small photodiode in the bottom right will get in the way. To remedy this, we desolder it and flip it to the opposite side of the board like this: The photodiode is not needed since we want the LED to always be on. Simply switching it to the opposite side leaves the original LED circuit unchanged.","title":"IR LED Circuit"},{"location":"setup/hw-setup/#assembly-bring-it-all-together","text":"Once you have all the hardware ready, you can begin assembly. Any glue can be used in this process, but we recommend hot glue for two main reasons. Hot glue drys quickly, so you do not need to wait a long time for the glue to dry. In addition, hot glue is removable if you make a mistake. To remove dried hot glue, soak the hot glue in in rubbing (isopropyl) alcohol. We recommend 90% concentration or higher, but 70% concentration will still work. Soaking the dried hot glue in isopropyl alcohol will weaken the bond between the glue and underlying surface, allowing you to peel the glue off cleanly. When soaking the glue in isopropyl alcohol, the Raspberry Pi should be powered off and unplugged. Be sure to let everything dry before reapplying hot glue and booting the Raspberry Pi. The assembly instructions below assume that you are using hot glue. If you are using a different type of glue, the assembly instructions still apply, though the drying times may differ. Throughout this process, make sure that the glue is dry before moving on to the next step. Throughout the build, check to make sure that all the ports can still be accessed through the holes in the baby monitor chassis. Click any of the pictures below for higher resolution images. Insert the Raspberry Pi into the chassis. Once it is in place, be sure that all of the ports can still be accessed (e.g. you can plug in power power). Next, use hot glue to tack the Pi into place and attach the camera to the Pi. There are screw holes as well if you prefer to use those. Glue the LED and camera to the front cover. First, glue the NoIR camera to the camera hole. Be sure that the camera is snug and lined up with the chassis. Do not use too much glue; otherwise, you will not be able to fit the camera into the main case. Be sure to power on the Pi and take a look at the camera ( raspistill -v , for example) to make sure that it is angled well and has a good field of view. If it is not, remove the hot glue and reposition it. Next, glue the IR LED to the hole on the neck of the cover. It's at a 45 degree angle to side light the crib, which results in more shadows in low-light situations. This adds more contrast to the image, making it easier to detect motion. With both of them glued to the neck, it should look like this: Attach the IR LED wires to the Raspberry Pi's GPIO pins as shown in the LED Schematic figure. Pack the cables into the chassis in a way that does not crease or strain them. We ended up folding the cable accordion style because our camera flex cable was too long. With everything tucked in, hot glue around the edges where the two pieces meet, sealing them in place.","title":"Assembly: Bring it all together"},{"location":"setup/sw-setup/","text":"Software Setup Guide This is the step-by-step guide on building the video-based baby monitor software on Raspbian/Ubuntu. Prerequisites This software depends on autoconf , libtool , OpenCV and libcanberra . Install these by running sudo apt-get install git build-essential libtool autoconf libopencv-dev libcanberra-dev Next you need to set to camera driver to autoload by adding bcm2835-v4l2 to /etc/modules-load.d/modules.conf . Your modules.conf should look like this: # /etc/modules: kernel modules to load at boot time. # # This file contains the names of kernel modules that should be loaded # at boot time, one per line. Lines beginning with \"#\" are ignored. i2c-dev bcm2835-v4l2 Once you've added the line and saved the file, reboot your Raspberry Pi . This is the driver used by the monitor to directly pull frames from the NoIR Camera. Build To build the software, navigate to the root of the repository directory and run ./autogen.sh --prefix=/usr --sysconfdir=/etc --disable-debug make sudo make install sudo systemctl daemon-reload Usage To start the program in the background: sudo systemctl start babymonitor To run it in the foreground: babymonitor --config /etc/babymonitor/config.ini To start the program automatically at every boot: sudo systemctl enable babymonitor To stop baby monitor from automatically running at boot: sudo systemctl disable babymonitor Note that when babymonitor is started using systemctl , the config parameters are already sent and are stored in /etc/systemd/system/babymonitor.service Once you have installed the software and have it configured well for your setting, you will no longer need the keyboard/mouse/monitor. Now, you can set your baby monitor to autorun at every boot as shown above. Now, all you'll need to do is plug in speakers, attach the baby monitor to your previously tested spot on the side of your crib, and plug it in. The software will automatically run after a few moments, and will begin tracking motion. When you're done, well, we don't have an elegant way for you to turn off the Pi yet. But, you can just unplug the speakers and leave it running (and be sure to set the infant in the crib for a couple minutes before plugging them back in). Directly unplugging the Pi may corrupt your SD card. Remember that if the environment changes, you'll probably need to reconfigure. You'll want to disable the autorun using the command above, and go through the calibration steps on the Configuration Page . If something doesn't seem to be working, you can checkout our Troubleshooting Page Tip: If everything is set up, you can make a backup of your Raspberry Pi SD Card for easy restoration if something goes wrong. Software Configuration Baby monitor customizable through a simple INI configuration file. After running make install , the configuration file is located at: sudo nano /etc/babymonitor/config.ini and it will look like this [io] ; I/O configuration ; input = vid/noir_cam/lowres_10fps_orange_2min.h264 ; Input file to use input_fps = 15 ; fps of input (40 max, 15 recommended if using camera) full_fps = 4.5 ; fps at which full frames can be processed crop_fps = 15 ; fps at which cropped frames can be processed camera = 0 ; Camera to use width = 640 ; Width of the input video height = 480 ; Height of the input video time_to_alarm = 10 ; How many seconds to wait with no motion before alarm. [cropping] ; Adaptive Cropping Settings crop = true ; Whether or not to crop frames_to_settle = 10 ; # frames to wait after reset before processing roi_update_interval = 800 ; # frames between recalculating ROI roi_window = 50 ; # frames to monitor before selecting ROI [motion] ; Motion Detection Settings erode_dim = 4 ; dimension of the erode kernel dilate_dim = 60 ; dimension of the dilate kernel diff_threshold = 8 ; abs difference needed before recognizing change duration = 1 ; # frames to maintain motion before flagging true pixel_threshold = 5 ; # pixels that must be different to flag as motion show_diff = false ; display the diff between 3 frames [magnification] ; Video Magnification Settings amplify = 25 ; The % amplification desired low-cutoff = 0.5 ; The low frequency of the bandpass. high-cutoff = 1.0 ; The high frequency of the bandpass. threshold = 50 ; The phase threshold as % of pi. show_magnification = false ; Show the output frames of each magnification [debug] print_times = false ; Print analysis times View the full configuration details on the Configuration Page Software Architecture Details The baby monitor software is the heart and soul of this project. The rest is mainly a fun opportunity to use a 3D printer and do some soldering. We saw some of the great demos of video magnification from MIT, and wanted to try and run a similar algorithm on a Raspberry Pi. This required about 10x speedup from the great work of tbl3rd on his C++ implementation of video magnification in order to run in real-time on the Pi. The optimizations needed guided our design of the software. The software for processing a video stream is implemented as a state machine that cycles as shown below. There are currently six states that manage all of our processing steps. Our state machine logic is called each time a new frame is read from the camera. Initialization When the video stream first turns on, it is common to have a flash of white or black pixels that looks like a lot of motion is happening. This state simply initializes the video magnification and motion detection code, and skips a few of the first frames before jumping into monitoring motion. Monitoring Motion In this state, the full 640 x 480 frame is magnified, and uses an image differential algorithm from Collins et al. to calculate the motion pixels between frames. The output of this algorithm is a black and white image where white pixels indicate pixels that have changed. These black and white images are then bitwise ORed together for several frames to accumulate the motion seen over the period of time. Computing a Region of Interest With the accumulated black and white frame representing the motion seen over several frames, the image is eroded slightly to eliminate noise, then significantly dilated to highlight the areas with the most motion. Dilation is necessary to merge discrete points into continuous regions of motion. Because of the large dilation, it is then easy to find the largest contour in the black and white image, which represents the main source of motion, and draw a bounding box around the contour. It is in this portion of code that we can set bounds on the size of the crop. Steady State This is where our software spends most of its time. In this state, the software is operating on cropped frames. Video magnification is performed and a measure of the movement seen in the frame is calculated. In this state, we are able to process at a fast enough rate to catch up with any delay caused during the processing of full frames, and keep up with our 10fps video stream. Periodic Reset Because the baby may move occasionally, we periodically reset the video magnification and cropping so that we have full-resolution frames available to repeat the process of monitoring motion and finding a new region of interest. All of these timing parameters are easily configurable. Technical Challenges Speed When we started this project, our C++ implementation could magnify video at a rate of 394,000 pixels per second on the Raspberry Pi 3. For reference, this meant our code could only process a 640 x 480 video stream at a rate of approximately 1.3 frames per second. Optimizing our code to handle the real-time goal was our primary objective and challenge, since we needed a 10x speed-up to handle at least 10 frames per second. Now, we are able to process over 1,200,000 pixels per second, and use additional cropping to process a 10 fps video stream in real time. We used three main optimizations increase performance by 10x: (1) multithreading, (2) adaptive cropping, and (3) compiler optimization. Each optimization is explained in more detail below. Multithreading (~3x) One intuitive and high-value optimization was to process sections of each video frame in parallel. To do so, we divide each frame vertically, such that each section's height is one-third of the original frame. Then, each section is magnified as if it was its own video stream. The resulting magnified frames are then joined together to form a full-resolution frame before evaluating the frame for motion. This optimization alone brought our processing rate to 938,000 pixels per second (roughly a 3x improvement). Three of the Raspberry Pi's four cores are dedicated to video magnification, while the 4th core handles control flow and motion processing. Adaptive Cropping (~3x) While multithreading sought to increase the number of pixels we could process each second, adaptive cropping sought to decrease the number of pixels we needed to process. We rely on two main assumptions for this optimization. First, the camera captures the entire crib in its field of view and the baby is the only source of movement in the frame. Second, the camera is placed such that movement is discernible, and the region of interest is not larger than one-third of the frame. With these assumptions, we are able to periodically monitor a full frame to determine where the motion is occurring, then crop down the stream to only contain the relevant motion. By reducing the number of pixels that we process in our steady state, and amortizing the cost of monitoring a few full-resolution frames, we are able to increase the number of frames we can handle each second by about 3x. Compiler Optimizations (~1.2x) Finally, in order to reach our goal of over 10x speedup, we were able to make some code optimizations and utilize additional compiler flags. In particular, we make use of the -O3 optimization level, and we force the compiler to generate vector instructions with -ftree-vectorize and -mfpu=crypto-neon-fp-armv8 . Additionally, we were required to add the -funsafe-math-optimization flag to enable the vector float generation, because NEON instructions are not IEEE compliant and gcc would not generate them otherwise. We found two major challenges in enabling compiler optimization. The first was to expose the operations to the compiler. The most expensive part of transformation happens in two all-pixel loops, but previously each operation in the loop was implemented with an opencv call that would run the operation over all pixels. We rewrote the code to pull out the loop and avoid intermediate copies. On an x86-64 machine, this is already an improvement, because of larger caches and the fact that the compiler always issues at least SSE2 vector instructions. In contrast, the switch from vector instruction enabled opencv to straight C++ code resulted in worse performance on the Pi. We recovered this performance drop by adding the compiler flags, but we encountered toolchain problems. The Pi 3 has an ARM Cortex A53 processor, which is an A-class 64-bit ARMv8 with NEON and crypto extensions, but it runs a 32-bit OS compiled for ARMv7. We found first that compiling with -march=native exposes a known but yet unfixed GCC bug. Compiling with -march=armv8 appears to work, but generates ABI incompatible binaries when linked with an ARMv7 libstdc++, leading to stack corruption. On the other hand, leaving the default of -march=armv7 and forcing just the FPU to generate NEON appears to work, looking at the assembly. We also added -mtune=cortex-a53 to achieve better instruction scheduling and better counts for loop unrolling (which is enabled at -O3), but we suspect it has no effect because the version of GCC we use (4.9.2, provided by Raspbian) does not recognize it. Profiling In order to isolate further optimization spots, we employed profiling to identify where the code is spending most of the time. In doing so, we also encountered toolchain problems, as valgrind is unable to emulate the NEON vector instructions and crashes. We therefore turned to gprof , but we found its timing somewhat unreliable, despite the -fno-inline switch (function call counts on the other hand are precise but not quite useful). Finally, we tried perf , which uses the HW performance counters and gives us instruction level timings, but we found that it is very precise inside the transformation code, and has zero data outside, because it sees no sample of the other code. Overall, profiling suggests that 96% of the time is spent in the transformation and 2% in motion detection, with the rest being threading and locking overhead, and accessing the camera. Timing Overall, our algorithm is able to process a full 640x480 frame in 220 to 240 ms, while after cropping our algorithm runs in the worst case (where the crop is approximately 320x320) at about 70 ms per frame. This allows us to maintain a steady 10 fps goal.","title":"Software Setup Instructions"},{"location":"setup/sw-setup/#software-setup-guide","text":"This is the step-by-step guide on building the video-based baby monitor software on Raspbian/Ubuntu.","title":"Software Setup Guide"},{"location":"setup/sw-setup/#prerequisites","text":"This software depends on autoconf , libtool , OpenCV and libcanberra . Install these by running sudo apt-get install git build-essential libtool autoconf libopencv-dev libcanberra-dev Next you need to set to camera driver to autoload by adding bcm2835-v4l2 to /etc/modules-load.d/modules.conf . Your modules.conf should look like this: # /etc/modules: kernel modules to load at boot time. # # This file contains the names of kernel modules that should be loaded # at boot time, one per line. Lines beginning with \"#\" are ignored. i2c-dev bcm2835-v4l2 Once you've added the line and saved the file, reboot your Raspberry Pi . This is the driver used by the monitor to directly pull frames from the NoIR Camera.","title":"Prerequisites"},{"location":"setup/sw-setup/#build","text":"To build the software, navigate to the root of the repository directory and run ./autogen.sh --prefix=/usr --sysconfdir=/etc --disable-debug make sudo make install sudo systemctl daemon-reload","title":"Build"},{"location":"setup/sw-setup/#usage","text":"To start the program in the background: sudo systemctl start babymonitor To run it in the foreground: babymonitor --config /etc/babymonitor/config.ini To start the program automatically at every boot: sudo systemctl enable babymonitor To stop baby monitor from automatically running at boot: sudo systemctl disable babymonitor Note that when babymonitor is started using systemctl , the config parameters are already sent and are stored in /etc/systemd/system/babymonitor.service Once you have installed the software and have it configured well for your setting, you will no longer need the keyboard/mouse/monitor. Now, you can set your baby monitor to autorun at every boot as shown above. Now, all you'll need to do is plug in speakers, attach the baby monitor to your previously tested spot on the side of your crib, and plug it in. The software will automatically run after a few moments, and will begin tracking motion. When you're done, well, we don't have an elegant way for you to turn off the Pi yet. But, you can just unplug the speakers and leave it running (and be sure to set the infant in the crib for a couple minutes before plugging them back in). Directly unplugging the Pi may corrupt your SD card. Remember that if the environment changes, you'll probably need to reconfigure. You'll want to disable the autorun using the command above, and go through the calibration steps on the Configuration Page . If something doesn't seem to be working, you can checkout our Troubleshooting Page Tip: If everything is set up, you can make a backup of your Raspberry Pi SD Card for easy restoration if something goes wrong.","title":"Usage"},{"location":"setup/sw-setup/#software-configuration","text":"Baby monitor customizable through a simple INI configuration file. After running make install , the configuration file is located at: sudo nano /etc/babymonitor/config.ini and it will look like this [io] ; I/O configuration ; input = vid/noir_cam/lowres_10fps_orange_2min.h264 ; Input file to use input_fps = 15 ; fps of input (40 max, 15 recommended if using camera) full_fps = 4.5 ; fps at which full frames can be processed crop_fps = 15 ; fps at which cropped frames can be processed camera = 0 ; Camera to use width = 640 ; Width of the input video height = 480 ; Height of the input video time_to_alarm = 10 ; How many seconds to wait with no motion before alarm. [cropping] ; Adaptive Cropping Settings crop = true ; Whether or not to crop frames_to_settle = 10 ; # frames to wait after reset before processing roi_update_interval = 800 ; # frames between recalculating ROI roi_window = 50 ; # frames to monitor before selecting ROI [motion] ; Motion Detection Settings erode_dim = 4 ; dimension of the erode kernel dilate_dim = 60 ; dimension of the dilate kernel diff_threshold = 8 ; abs difference needed before recognizing change duration = 1 ; # frames to maintain motion before flagging true pixel_threshold = 5 ; # pixels that must be different to flag as motion show_diff = false ; display the diff between 3 frames [magnification] ; Video Magnification Settings amplify = 25 ; The % amplification desired low-cutoff = 0.5 ; The low frequency of the bandpass. high-cutoff = 1.0 ; The high frequency of the bandpass. threshold = 50 ; The phase threshold as % of pi. show_magnification = false ; Show the output frames of each magnification [debug] print_times = false ; Print analysis times View the full configuration details on the Configuration Page","title":"Software Configuration"},{"location":"setup/sw-setup/#software-architecture-details","text":"The baby monitor software is the heart and soul of this project. The rest is mainly a fun opportunity to use a 3D printer and do some soldering. We saw some of the great demos of video magnification from MIT, and wanted to try and run a similar algorithm on a Raspberry Pi. This required about 10x speedup from the great work of tbl3rd on his C++ implementation of video magnification in order to run in real-time on the Pi. The optimizations needed guided our design of the software. The software for processing a video stream is implemented as a state machine that cycles as shown below. There are currently six states that manage all of our processing steps. Our state machine logic is called each time a new frame is read from the camera.","title":"Software Architecture Details"},{"location":"setup/sw-setup/#initialization","text":"When the video stream first turns on, it is common to have a flash of white or black pixels that looks like a lot of motion is happening. This state simply initializes the video magnification and motion detection code, and skips a few of the first frames before jumping into monitoring motion.","title":"Initialization"},{"location":"setup/sw-setup/#monitoring-motion","text":"In this state, the full 640 x 480 frame is magnified, and uses an image differential algorithm from Collins et al. to calculate the motion pixels between frames. The output of this algorithm is a black and white image where white pixels indicate pixels that have changed. These black and white images are then bitwise ORed together for several frames to accumulate the motion seen over the period of time.","title":"Monitoring Motion"},{"location":"setup/sw-setup/#computing-a-region-of-interest","text":"With the accumulated black and white frame representing the motion seen over several frames, the image is eroded slightly to eliminate noise, then significantly dilated to highlight the areas with the most motion. Dilation is necessary to merge discrete points into continuous regions of motion. Because of the large dilation, it is then easy to find the largest contour in the black and white image, which represents the main source of motion, and draw a bounding box around the contour. It is in this portion of code that we can set bounds on the size of the crop.","title":"Computing a Region of Interest"},{"location":"setup/sw-setup/#steady-state","text":"This is where our software spends most of its time. In this state, the software is operating on cropped frames. Video magnification is performed and a measure of the movement seen in the frame is calculated. In this state, we are able to process at a fast enough rate to catch up with any delay caused during the processing of full frames, and keep up with our 10fps video stream.","title":"Steady State"},{"location":"setup/sw-setup/#periodic-reset","text":"Because the baby may move occasionally, we periodically reset the video magnification and cropping so that we have full-resolution frames available to repeat the process of monitoring motion and finding a new region of interest. All of these timing parameters are easily configurable.","title":"Periodic Reset"},{"location":"setup/sw-setup/#technical-challenges","text":"","title":"Technical Challenges"},{"location":"setup/sw-setup/#speed","text":"When we started this project, our C++ implementation could magnify video at a rate of 394,000 pixels per second on the Raspberry Pi 3. For reference, this meant our code could only process a 640 x 480 video stream at a rate of approximately 1.3 frames per second. Optimizing our code to handle the real-time goal was our primary objective and challenge, since we needed a 10x speed-up to handle at least 10 frames per second. Now, we are able to process over 1,200,000 pixels per second, and use additional cropping to process a 10 fps video stream in real time. We used three main optimizations increase performance by 10x: (1) multithreading, (2) adaptive cropping, and (3) compiler optimization. Each optimization is explained in more detail below.","title":"Speed"},{"location":"setup/sw-setup/#multithreading-3x","text":"One intuitive and high-value optimization was to process sections of each video frame in parallel. To do so, we divide each frame vertically, such that each section's height is one-third of the original frame. Then, each section is magnified as if it was its own video stream. The resulting magnified frames are then joined together to form a full-resolution frame before evaluating the frame for motion. This optimization alone brought our processing rate to 938,000 pixels per second (roughly a 3x improvement). Three of the Raspberry Pi's four cores are dedicated to video magnification, while the 4th core handles control flow and motion processing.","title":"Multithreading (~3x)"},{"location":"setup/sw-setup/#adaptive-cropping-3x","text":"While multithreading sought to increase the number of pixels we could process each second, adaptive cropping sought to decrease the number of pixels we needed to process. We rely on two main assumptions for this optimization. First, the camera captures the entire crib in its field of view and the baby is the only source of movement in the frame. Second, the camera is placed such that movement is discernible, and the region of interest is not larger than one-third of the frame. With these assumptions, we are able to periodically monitor a full frame to determine where the motion is occurring, then crop down the stream to only contain the relevant motion. By reducing the number of pixels that we process in our steady state, and amortizing the cost of monitoring a few full-resolution frames, we are able to increase the number of frames we can handle each second by about 3x.","title":"Adaptive Cropping (~3x)"},{"location":"setup/sw-setup/#compiler-optimizations-12x","text":"Finally, in order to reach our goal of over 10x speedup, we were able to make some code optimizations and utilize additional compiler flags. In particular, we make use of the -O3 optimization level, and we force the compiler to generate vector instructions with -ftree-vectorize and -mfpu=crypto-neon-fp-armv8 . Additionally, we were required to add the -funsafe-math-optimization flag to enable the vector float generation, because NEON instructions are not IEEE compliant and gcc would not generate them otherwise. We found two major challenges in enabling compiler optimization. The first was to expose the operations to the compiler. The most expensive part of transformation happens in two all-pixel loops, but previously each operation in the loop was implemented with an opencv call that would run the operation over all pixels. We rewrote the code to pull out the loop and avoid intermediate copies. On an x86-64 machine, this is already an improvement, because of larger caches and the fact that the compiler always issues at least SSE2 vector instructions. In contrast, the switch from vector instruction enabled opencv to straight C++ code resulted in worse performance on the Pi. We recovered this performance drop by adding the compiler flags, but we encountered toolchain problems. The Pi 3 has an ARM Cortex A53 processor, which is an A-class 64-bit ARMv8 with NEON and crypto extensions, but it runs a 32-bit OS compiled for ARMv7. We found first that compiling with -march=native exposes a known but yet unfixed GCC bug. Compiling with -march=armv8 appears to work, but generates ABI incompatible binaries when linked with an ARMv7 libstdc++, leading to stack corruption. On the other hand, leaving the default of -march=armv7 and forcing just the FPU to generate NEON appears to work, looking at the assembly. We also added -mtune=cortex-a53 to achieve better instruction scheduling and better counts for loop unrolling (which is enabled at -O3), but we suspect it has no effect because the version of GCC we use (4.9.2, provided by Raspbian) does not recognize it.","title":"Compiler Optimizations (~1.2x)"},{"location":"setup/sw-setup/#profiling","text":"In order to isolate further optimization spots, we employed profiling to identify where the code is spending most of the time. In doing so, we also encountered toolchain problems, as valgrind is unable to emulate the NEON vector instructions and crashes. We therefore turned to gprof , but we found its timing somewhat unreliable, despite the -fno-inline switch (function call counts on the other hand are precise but not quite useful). Finally, we tried perf , which uses the HW performance counters and gives us instruction level timings, but we found that it is very precise inside the transformation code, and has zero data outside, because it sees no sample of the other code. Overall, profiling suggests that 96% of the time is spent in the transformation and 2% in motion detection, with the rest being threading and locking overhead, and accessing the camera.","title":"Profiling"},{"location":"setup/sw-setup/#timing","text":"Overall, our algorithm is able to process a full 640x480 frame in 220 to 240 ms, while after cropping our algorithm runs in the worst case (where the crop is approximately 320x320) at about 70 ms per frame. This allows us to maintain a steady 10 fps goal.","title":"Timing"},{"location":"setup/troubleshooting/","text":"Troubleshooting Here are some troubleshooting tips we've gathered while making baby monitor. No alarm is playing Are your speakers working? Can you play other sounds from the Pi outside of the baby monitor alarm? Is your Pi trying to play audio through HDMI rather than the audio port? Check the Raspberry Pi Audio Configuration page to make sure that you have selected the right output. Is baby monitor detecting motion? Check with journalctl -f to see if baby monitor is running in the background. If it is, perhaps you need to calibrate babymonitor IR LED is not working Can you see a faint red color when you look at the IR LED? A faint red ring should be visible when the LED is on. Check the polarity of the connections. If +5V and GND are reversed, it will not work. Connect the LED to a power supply with a 5V/0.5A voltage/current limit. Normally, it should consume 0.2A at 5V. If it does not, your LED may be malfunctioning. Baby monitor is detecting motion even though there isn't an infant Have you properly configured babymonitor ? Remember, baby monitor is just looking for changes in pixel values Is there a moving shadow within the frame? Is there flickering or changing lighting? Is baby monitor mounted to a stable surface (e.g. something that won't shake if people are walking by it)? Is there any other sources of movement in the frame (mirrors catching reflections, etc)? Baby monitor is NOT detecting motion even though there is motion Have you properly configured babymonitor ? Is there anything in the way of the camera? Are you able to connect to the camera from the Raspberry Pi at all? Check by running raspistill -v in a terminal to open the camera on the Pi for a few seconds. If you look at sudo systemctl status babymonitor , is it actually running? Is your infant under a blanket that is \"tented\" up so that it is not making contact with the child? If there are significant air gaps between the blanket and the child, the blanket may mask the motion. Can you see the motion if you amplify the video more? Can you see the motion if you tune the low and high frequency cutoffs? If this is happening in low-light only, did you make sure your calibration works in low-light? Baby monitor doesn't build Did you install all of the dependencies ? I can't run babymonitor from the commandline Did you accidentally mistype anything when you ran ./autogen.sh --prefix=/usr --sysconfdir=/etc --disable-debug during your software build? Is babymonitor present in /usr/bin/ ?","title":"Troubleshooting"},{"location":"setup/troubleshooting/#troubleshooting","text":"Here are some troubleshooting tips we've gathered while making baby monitor.","title":"Troubleshooting"},{"location":"setup/troubleshooting/#no-alarm-is-playing","text":"Are your speakers working? Can you play other sounds from the Pi outside of the baby monitor alarm? Is your Pi trying to play audio through HDMI rather than the audio port? Check the Raspberry Pi Audio Configuration page to make sure that you have selected the right output. Is baby monitor detecting motion? Check with journalctl -f to see if baby monitor is running in the background. If it is, perhaps you need to calibrate babymonitor","title":"No alarm is playing"},{"location":"setup/troubleshooting/#ir-led-is-not-working","text":"Can you see a faint red color when you look at the IR LED? A faint red ring should be visible when the LED is on. Check the polarity of the connections. If +5V and GND are reversed, it will not work. Connect the LED to a power supply with a 5V/0.5A voltage/current limit. Normally, it should consume 0.2A at 5V. If it does not, your LED may be malfunctioning.","title":"IR LED is not working"},{"location":"setup/troubleshooting/#baby-monitor-is-detecting-motion-even-though-there-isnt-an-infant","text":"Have you properly configured babymonitor ? Remember, baby monitor is just looking for changes in pixel values Is there a moving shadow within the frame? Is there flickering or changing lighting? Is baby monitor mounted to a stable surface (e.g. something that won't shake if people are walking by it)? Is there any other sources of movement in the frame (mirrors catching reflections, etc)?","title":"Baby monitor is detecting motion even though there isn't an infant"},{"location":"setup/troubleshooting/#baby-monitor-is-not-detecting-motion-even-though-there-is-motion","text":"Have you properly configured babymonitor ? Is there anything in the way of the camera? Are you able to connect to the camera from the Raspberry Pi at all? Check by running raspistill -v in a terminal to open the camera on the Pi for a few seconds. If you look at sudo systemctl status babymonitor , is it actually running? Is your infant under a blanket that is \"tented\" up so that it is not making contact with the child? If there are significant air gaps between the blanket and the child, the blanket may mask the motion. Can you see the motion if you amplify the video more? Can you see the motion if you tune the low and high frequency cutoffs? If this is happening in low-light only, did you make sure your calibration works in low-light?","title":"Baby monitor is NOT detecting motion even though there is motion"},{"location":"setup/troubleshooting/#baby-monitor-doesnt-build","text":"Did you install all of the dependencies ?","title":"Baby monitor doesn't build"},{"location":"setup/troubleshooting/#i-cant-run-babymonitor-from-the-commandline","text":"Did you accidentally mistype anything when you ran ./autogen.sh --prefix=/usr --sysconfdir=/etc --disable-debug during your software build? Is babymonitor present in /usr/bin/ ?","title":"I can't run babymonitor from the commandline"}]}